<!doctype html>
<html lang="zh-Hant" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-react/learn" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">React | P&amp;P 的 筆記</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://blog.papersuniverse.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://blog.papersuniverse.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://blog.papersuniverse.com/docs/react/learn"><meta data-rh="true" property="og:locale" content="zh_Hant"><meta data-rh="true" name="docusaurus_locale" content="zh-Hant"><meta data-rh="true" name="docsearch:language" content="zh-Hant"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="React | P&amp;P 的 筆記"><meta data-rh="true" name="description" content="寫 react 重要的事情"><meta data-rh="true" property="og:description" content="寫 react 重要的事情"><link data-rh="true" rel="icon" href="/img/ico-star.png"><link data-rh="true" rel="canonical" href="https://blog.papersuniverse.com/docs/react/learn"><link data-rh="true" rel="alternate" href="https://blog.papersuniverse.com/docs/react/learn" hreflang="zh-Hant"><link data-rh="true" rel="alternate" href="https://blog.papersuniverse.com/docs/react/learn" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.069b8a9f.css">
<script src="/assets/js/runtime~main.69c2901e.js" defer="defer"></script>
<script src="/assets/js/main.4cb1b457.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳至主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳至主要内容</a></div><nav aria-label="主導航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切換導覽列" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">P&amp;P的筆記</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/category/prosemirror">文章列表</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切換淺色/深色模式（當前為淺色模式）" aria-label="切換淺色/深色模式（當前為淺色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到頂部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文件側邊欄" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/prosemirror">ProseMirror</a><button aria-label="展開側邊欄分類 &#x27;ProseMirror&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/react-學習筆記">React 學習筆記</a><button aria-label="收起側邊欄分類 &#x27;React 學習筆記&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/react/learn">React</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/react/nextjs">nextjs</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="頁面路徑"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主頁面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/react-學習筆記"><span itemprop="name">React 學習筆記</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">React</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本頁導覽</button></div><div class="theme-doc-markdown markdown"><header><h1>React</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="寫-react-重要的事情">寫 react 重要的事情<a href="#寫-react-重要的  事情" class="hash-link" aria-label="寫 react 重要的事情的直接連結" title="寫 react 重要的事情的直接連結">​</a></h2>
<ol>
<li>
<p>究竟什麼狀態要用 useState()，要好好思考，是什麼狀態在控制畫面 render</p>
</li>
<li>
<p>用 pure function 的概念去思考</p>
<ul>
<li>避免 mutate 到外部已存在的 variable</li>
<li>same input, same output(所寫的 react component 應該要回傳一致的 jsx)</li>
</ul>
</li>
<li>
<p>在 rendering 時執行的 function，必須是 pure，但 event handler... 不需要是 pure</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="關於-usestate">關於 useState<a href="#關於-usestate" class="hash-link" aria-label="關於 useState的直接連結" title="關於 useState的直接連結">​</a></h2>
<ol>
<li>當有狀態需要在 react 更新組件間被記住時，用 useState</li>
<li>state 在 component 裡是私有的</li>
<li>每個當下的 state 是固定的，像快照般。就算是非同步操作，也不會因為 state 再後續有變化，而影響非同步執行的 function，<a href="https://react.dev/learn/state-as-a-snapshot" target="_blank" rel="noopener noreferrer">詳見 state as a snapshot</a></li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="關於-useeffect">關於 useEffect<a href="#關於-useeffect" class="hash-link" aria-label="關於 useEffect的直接連結" title="關於 useEffect的直接連結">​</a></h2>
<ul>
<li>在 rendering 的時候，如果以一些 side effect 行為，可以 useEffect 裡面處理。</li>
<li>應用場景通常不是 使用者互動，因為互動會在 handler 裡處理。</li>
<li>一般來說，useEffect 在 react commit 後執行（render 完 Dom 後）</li>
<li>如果前次 render 的 dependency 值與這次一樣，useEffect 會被 react 跳過</li>
<li>通常決定要以什麼為 dependency 的準則是 useEffect 裡用到什麼樣的狀態</li>
<li>如果 dependency 是空的，則代表只會在 component mount 時執行一次</li>
<li>Strict Mode 下，react 為了測試程式穩定性，會 remount component。</li>
<li>如果因為 remount 導致程式有問題，通常需要 cleanup function</li>
<li>在執行下一次 effect 時，react 會 call cleanup function</li>
</ul>
<p>useEffetc 會比較前次 render，如果作為 dependency 的 state 在 2 次 render 中不一樣（Object.is()）
則會在這次 render 之後，執行 callback</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="你可能不需要-effect">你可能不需要 effect<a href="#你可能不需要-effect" class="hash-link" aria-label="你可能不需要 effect的直接連結" title="你可能不需要 effect的直接連結">​</a></h2>
<ul>
<li>如果在 render 時計算其他值，不需要 effect</li>
<li>要 cache 某個相對耗效能的操作，使用 useMemo（我覺得就像是 vue 的 computed）</li>
<li>如果要透過改變 prop 重設 子component 內部所有的 state，可以給子 componet 加上 key</li>
<li>如果要改變許多不同元件的 state，盡量放在一個 event 一起更新，善用 react batch update 的設計</li>
<li>如果要在不同的元件同步同一個狀態值，先考慮 lift state up</li>
<li>可以在 effect 裡 fetch data，但要加上 cleanup function 避免 race condition</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="如何判斷何時該用-useeffect">如何判斷何時該用 useEffect<a href="#如何判斷何時該用-useeffect" class="hash-link" aria-label="如何判斷何時該用 useEffect的直接連結" title="如何判斷何時該用 useEffect的直接連結">​</a></h2>
<p>情境：當要決定程式邏輯應該放在 event handler 或是 useEffect 時，要從使用者的視角思考，這段邏輯究竟是特定互動，或者是 user 在 component render 後，才會呈現的內容，若是前者，請放在 event handler，若是後者，請放在 useEffect。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="在寫-useeffect-的時候應該思考什麼">在寫 useEffect 的時候，應該思考什麼<a href="#在寫-useeffect-的時候應該思考什麼" class="hash-link" aria-label="在寫 useEffect 的時候，應該思考什麼的直接連結" title="在寫 useEffect 的時候，應該思考什麼的直接連結">​</a></h2>
<p>react 官方建議，寫 useEffect 要專注在狀態什麼時候該重新同步，而<strong>不是</strong>思考現在 component 是什麼階段（mounted/unmount...）</p>
<p>在 react 裡，所有在 component 裡的變數，都視為 reactive 的，
有些變數可能是依據不同的 props 有不同的值，
但同樣在 render 時會改變，
所以是 reactive 的。</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function ChatRoom({ roomId, selectedServerUrl }) { // roomId is reactive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const settings = useContext(SettingsContext); // settings is reactive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  useEffect(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connection.connect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      connection.disconnect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reactstrictmode">React.StrictMode<a href="#reactstrictmode" class="hash-link" aria-label="React.StrictMode的直接連結" title="React.StrictMode的直接連結">​</a></h3>
<p>在這個模式底下，react 會 render component 2 次，這是為了測試 component 是不是 pure function</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jsx-介紹">JSX 介紹<a href="#jsx-介紹" class="hash-link" aria-label="JSX 介紹的直接連結" title="JSX 介紹的直接連結">​</a></h2>
<p>react 推薦使用 JSX。透過 JSX 來產出 react 的元件。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="為什麼要使用-jsx">為什麼要使用 JSX<a href="#為什麼要使用-jsx" class="hash-link" aria-label="為什麼要使用 JSX的直接連結" title="為什麼要使用 JSX的直接連結">​</a></h3>
<p>react 認為畫面渲染的邏輯與 ui 邏輯、事件處理、狀態改變，應該要一起處理。
所以相較於把 html 標記語言和程式邏輯分離，react 認為更應該把一小部分的這些東西一起處理，也就是 component 的概念。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jsx-可預防-xss-攻擊">JSX 可預防 XSS 攻擊<a href="#jsx-可預防-xss-攻擊" class="hash-link" aria-label="JSX 可預防 XSS 攻擊的直接連結" title="JSX 可預防 XSS 攻擊的直接連結">​</a></h3>
<p>所有注入 JSX 的變數都會被轉為字串，可以確保其他非自己 app 的程式，也不會造成 xss 攻擊。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jsx-即物件">JSX 即物件<a href="#jsx-即物件" class="hash-link" aria-label="JSX 即物件的直接連結" title="JSX 即物件的直接連結">​</a></h3>
<p>Babel 會 compile JSX 為 React.createElement()</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const element = (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Hello, world!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/h1&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const element = React.createElement(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &#x27;h1&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {className: &#x27;greeting&#x27;},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &#x27;Hello, world!&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>React.createElement</code> 會產出類似這樣的物件(這是簡單版)</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 簡單的表示，實際上更複雜</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const element = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type: &#x27;h1&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    props: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        className: &#x27;greeting&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        children: &#x27;Hello, world&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 這個 object 叫做 &#x27;React elements&#x27;，React 會用這個 object 去建立 DOM 並持續更新。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="rendering-element">Rendering Element<a href="#rendering-element" class="hash-link" aria-label="Rendering Element的直接連結" title="Rendering Element的直接連結">​</a></h2>
<p>Element 是 react app 的最小單元。</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>React element 是一個 plain object（大致上的意思是物件的 prototype 是 Object.prototype）
相較於 DOM 來說，開銷是更小的。
React DOM 會去依照 React element 去更新 DOM</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>資訊</div><div class="admonitionContent_BuS1"><p>要注意的是 element 不是 component。componet 是由 element 組成的。</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="將-element-渲染為-dom-元素">將 element 渲染為 DOM 元素<a href="#將-element-渲染為-dom-元素" class="hash-link" aria-label="將 element 渲染為 DOM 元素的直接連結" title="將 element 渲染為 DOM 元素的直接連結">​</a></h3>
<p>會透過一個 root div，讓 React DOM 管理裡面的渲染邏輯</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const root = ReactDOM.createRoot(document.getElementBtId(&#x27;root&#x27;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const element = &lt;h1&gt;hello world&lt;/h1&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root.render(element);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>React element 是 immutable 的，所以一但建立之後，就無法改變他的子層或attribute。
一個 element 就像是電影中的某一個影格，代表某個狀態下，ui 的樣子。
改變 ui 的唯一辦法就是創一個新的 element，然後重新 <code>root.render()</code> 一次</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>資訊</div><div class="admonitionContent_BuS1"><p>實際上，大部分的 React app 只執行 root.render() 一次。之後會介紹，如何去封裝有狀態的 component。</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="react-只-update-有需要更新的部分">React 只 update 有需要更新的部分<a href="#react-只-update-有需要更新的部分" class="hash-link" aria-label="React 只 update 有需要更新的部分的直接連結" title="React 只 update 有需要更新的部分的直接連結">​</a></h3>
<p>ReactDOM 會將 element 和它的 children 與先前的狀態做比較，必且只更新必要的 DOM。</p>
<p>但只要 component 的 state 有改變，整個 component 包含其子 component 都會 re-render。
要注意的是，componet render 產生的是 renderering elements，</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="components-和-props">Components 和 props<a href="#components-和-props" class="hash-link" aria-label="Components 和 props的直接連結" title="Components 和 props的直接連結">​</a></h2>
<p>Componet 讓我們把 ui 切成可以複用、獨立且隔離的一個單元。概念上，component 就像是 Javscript Function，接受任意的輸入(也就是 props)，並且回傳 React elements。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="function-components">Function components<a href="#function-components" class="hash-link" aria-label="Function components的直接連結" title="Function components的直接連結">​</a></h3>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function Welcome(props) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return `&lt;h1&gt;Hello!, {props.name}&lt;/h1&gt;`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="class-components">class components<a href="#class-components" class="hash-link" aria-label="class components的直接連結" title="class components的直接連結">​</a></h3>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Welcome extends React.Component {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    render() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;h1&gt;Hello!, {this.props.name}&lt;/h1&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以創造一個自定義的元件，給 React render</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const element = &lt;Welcome name=&quot;paper&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const root = React.createRoot(document.getElementById(&#x27;app&#x27;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root.render(element)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>當 react 發現這是一個自定義元件時，會把 jsx 上的 attribute 和 children 當作 object 傳入，也就是我們說的 props。</p>
<p>複習一下 code 上面的發生什麼事</p>
<ol>
<li>root.render()  帶入了 <code>&lt;Welcome name=&quot;paper&quot;/&gt;</code></li>
<li>觸發 welcome componet 並帶入 <code>{name: &#x27;paper&#x27;}</code> 為 props</li>
<li>welcome component 回傳 <code>&lt;h1&gt;Hello!, paper&lt;/h1&gt; element</code></li>
<li>React Dom 更新 dom 以符合  <code>&lt;h1&gt;Hello!, paper&lt;/h1&gt;</code></li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hooks">Hooks<a href="#hooks" class="hash-link" aria-label="Hooks的直接連結" title="Hooks的直接連結">​</a></h2>
<p>hook 只能放在 react component 的第一層，不要在 if..else, loop 裡面使用 hook</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="usestate">useState<a href="#usestate" class="hash-link" aria-label="useState的直接連結" title="useState的直接連結">​</a></h3>
<p>使用 useState 是在告訴 React 希望該 component 記住這個 state</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="關於-state-的更新">關於 state 的更新<a href="#關於-state-的更新" class="hash-link" aria-label="關於 state 的更新的直接連結" title="關於 state 的更新的直接連結">​</a></h2>
<p>if you would like to update the same state variable multiple times before the next render, instead of passing the next state value like setNumber(number + 1), you can pass a function that calculates the next state based on the previous one in the queue</p>
<div class="language-jsx= codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsx= codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function StateWontChangeUtilNextRender() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const [count, setCount] = useState(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;{count}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;Button onClick={() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 這樣 count 只會加 1 次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // setCount(count + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // setCount(count + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // setCount(count + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 若要在 react 下次 render 前，持續增加 count，可以這樣寫</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // react 會把傳入的 function 加入 queue ，  等到下次 render 時，帶入前一個 queue 的 state 執行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      setCount((prevCount) =&gt; prevCount + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      setCount((prevCount) =&gt; prevCount + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      setCount((prevCount) =&gt; prevCount + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }}&gt;+1 還 +3&lt;/Button&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製程式碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="何謂-batching">何謂 batching<a href="#何謂-batching" class="hash-link" aria-label="何謂 batching的直接連結" title="何謂 batching的直接連結">​</a></h3>
<p>React processes state updates after event handlers have finished running. This is called batching.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="preserving-state-and-resetting-state">Preserving state and Resetting state<a href="#preserving-state-and-resetting-state" class="hash-link" aria-label="Preserving state and Resetting state的直接連結" title="Preserving state and Resetting state的直接連結">​</a></h2>
<ol>
<li>React 透過 component render tree 繫結 state 到相對應的 component。其實 state 並不是儲存在 component 裡，儘管從程式碼看起來像是如此。（State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.)</li>
<li>react 預設透過 render tree 的 order 來辨別 component，可以透過 key 來告訴 recact 這個 component 的唯一性。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="react-更新畫面的流程render-and-commit">React 更新畫面的流程(Render and Commit)<a href="#react-更新畫面的流程render-and-commit" class="hash-link" aria-label="React 更新畫面的流程(Render and Commit)的直接連結" title="React 更新畫面的流程(Render and Commit)的直接連結">​</a></h2>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>資訊</div><div class="admonitionContent_BuS1"><p>“Rendering” means that React is calling your component, which is a function.</p></div></div>
<ol>
<li>Trigger a render
2 種可能會導致 component render，1 是 component 的初次 render，2 是 component 或是他祖先的 state 被改變了。</li>
<li>React renders your components<!-- -->
<ul>
<li>初次 render：react call root component（btw: react 使用 createElement 建立元素）</li>
<li>後續的 render：React call 有改變 state 的 component（btw：此時 react 會去比對並紀錄 commponet 有變動的地方）</li>
</ul>
</li>
<li>React commits changes to the DOM<!-- -->
<ul>
<li>初次 render：react 透過 appendChild() 將所有 DOM node 加入畫面</li>
<li>後續的 render：react 透過最小的改動更新畫面</li>
</ul>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="react-如何處理大量更新-state-而產生的多次-render">React 如何處理大量更新 state 而產生的多次 render<a href="#react-如何處理大量更新-state-而產生的多次-render" class="hash-link" aria-label="React 如何處理大量更新 state 而產生的多次 render的直接連結" title="React 如何處理大量更新 state 而產生的多次 render的直接連結">​</a></h2>
<p>react 等所有 handler 跑完之後，才會去更新 states
React processes state updates after event handlers have finished running. This is called batching.</p>
<p>updater function 必須是 pure function，因為它在 react render component 時執行。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-is-mutating-state-not-recommended-in-react">Why is mutating state not recommended in React?<a href="#why-is-mutating-state-not-recommended-in-react" class="hash-link" aria-label="Why is mutating state not recommended in React?的直接連結" title="Why is mutating state not recommended in React?的直接連結">​</a></h2>
<ul>
<li>debug：透過 conosle.log debug 時，如果每次都返回一個值，就可以看出物件改變的歷程。</li>
<li>optimization：如果前次 state、props 與這次相同，react 就可以跳過不處理，這是其優化的策略。如果禁止 mutate object 的話，就可以相當簡單的用 <code>obj === obj</code> 來判斷是否相同了。</li>
</ul>
<p>還有其他原因，但我覺得相對不那重要</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="usecallback">useCallback<a href="#usecallback" class="hash-link" aria-label="useCallback的直接連結" title="useCallback的直接連結">​</a></h2>
<h1>其他 lib</h1>
<p>SWR, Redux</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/react/learn.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>編輯此頁</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件選項卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/react-學習筆記"><div class="pagination-nav__sublabel">上一頁</div><div class="pagination-nav__label">React 學習筆記</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/react/nextjs"><div class="pagination-nav__sublabel">下一頁</div><div class="pagination-nav__label">nextjs</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#寫-react-重要的事情" class="table-of-contents__link toc-highlight">寫 react 重要的事情</a></li><li><a href="#關於-usestate" class="table-of-contents__link toc-highlight">關於 useState</a></li><li><a href="#關於-useeffect" class="table-of-contents__link toc-highlight">關於 useEffect</a></li><li><a href="#你可能不需要-effect" class="table-of-contents__link toc-highlight">你可能不需要 effect</a></li><li><a href="#如何判斷何時該用-useeffect" class="table-of-contents__link toc-highlight">如何判斷何時該用 useEffect</a></li><li><a href="#在寫-useeffect-的時候應該思考什麼" class="table-of-contents__link toc-highlight">在寫 useEffect 的時候，應該思考什麼</a><ul><li><a href="#reactstrictmode" class="table-of-contents__link toc-highlight">React.StrictMode</a></li></ul></li><li><a href="#jsx-介紹" class="table-of-contents__link toc-highlight">JSX 介紹</a><ul><li><a href="#為什麼要使用-jsx" class="table-of-contents__link toc-highlight">為什麼要使用 JSX</a></li><li><a href="#jsx-可預防-xss-攻擊" class="table-of-contents__link toc-highlight">JSX 可預防 XSS 攻擊</a></li><li><a href="#jsx-即物件" class="table-of-contents__link toc-highlight">JSX 即物件</a></li></ul></li><li><a href="#rendering-element" class="table-of-contents__link toc-highlight">Rendering Element</a><ul><li><a href="#將-element-渲染為-dom-元素" class="table-of-contents__link toc-highlight">將 element 渲染為 DOM 元素</a></li><li><a href="#react-只-update-有需要更新的部分" class="table-of-contents__link toc-highlight">React 只 update 有需要更新的部分</a></li></ul></li><li><a href="#components-和-props" class="table-of-contents__link toc-highlight">Components 和 props</a><ul><li><a href="#function-components" class="table-of-contents__link toc-highlight">Function components</a></li><li><a href="#class-components" class="table-of-contents__link toc-highlight">class components</a></li></ul></li><li><a href="#hooks" class="table-of-contents__link toc-highlight">Hooks</a><ul><li><a href="#usestate" class="table-of-contents__link toc-highlight">useState</a></li></ul></li><li><a href="#關於-state-的更新" class="table-of-contents__link toc-highlight">關於 state 的更新</a><ul><li><a href="#何謂-batching" class="table-of-contents__link toc-highlight">何謂 batching</a></li></ul></li><li><a href="#preserving-state-and-resetting-state" class="table-of-contents__link toc-highlight">Preserving state and Resetting state</a></li><li><a href="#react-更新畫面的流程render-and-commit" class="table-of-contents__link toc-highlight">React 更新畫面的流程(Render and Commit)</a></li><li><a href="#react-如何處理大量更新-state-而產生的多次-render" class="table-of-contents__link toc-highlight">React 如何處理大量更新 state 而產生的多次 render</a></li><li><a href="#why-is-mutating-state-not-recommended-in-react" class="table-of-contents__link toc-highlight">Why is mutating state not recommended in React?</a></li><li><a href="#usecallback" class="table-of-contents__link toc-highlight">useCallback</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/wen0720" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 P&P筆記, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>